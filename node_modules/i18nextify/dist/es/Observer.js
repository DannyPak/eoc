import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

import EventEmitter from './EventEmitter';

var Observer = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Observer, _EventEmitter);

  var _super = _createSuper(Observer);

  function Observer(ele) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Observer);

    _this = _super.call(this);
    _this.ele = ele;
    _this.options = options;
    _this.observer = _this.create();
    _this.internalChange = true;
    return _this;
  }

  _createClass(Observer, [{
    key: "create",
    value: function create() {
      var _this2 = this;

      var lastToggleTimeout;

      var toggleInternal = function toggleInternal() {
        if (lastToggleTimeout) window.clearTimeout(lastToggleTimeout);
        lastToggleTimeout = setTimeout(function () {
          if (_this2.internalChange) _this2.internalChange = false;
        }, 200);
      };

      var observer = new MutationObserver(function (mutations) {
        // For the sake of...observation...let's output the mutation to console to see how this all works
        // mutations.forEach(function(mutation) {
        // 	console.log(mutation.type);
        // });
        if (_this2.internalChange) toggleInternal();
        if (!_this2.internalChange) _this2.emit('changed', mutations);
      }); // Notify me of everything!

      var observerConfig = {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      }; // Node, config
      // In this case we'll listen to all changes to body and child nodes

      observer.observe(this.ele, observerConfig);
      return observer;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.internalChange = true;
    }
  }]);

  return Observer;
}(EventEmitter);

export { Observer as default };