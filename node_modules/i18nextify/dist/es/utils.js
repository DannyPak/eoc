import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
export function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
}
export function getAttribute(node, attr) {
  return node.properties && node.properties.attributes && node.properties.attributes[attr];
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();
    object = object[key];
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

export function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}
export function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}
export function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}
export function getPathname() {
  var path = location.pathname;
  if (path === '/') return 'root';
  var parts = path.split('/');
  var ret = 'root';
  parts.forEach(function (p) {
    if (p) ret += "_".concat(p);
  });
  return ret;
}
export var parseOptions = function parseOptions(options) {
  if (options.namespace) {
    options.ns.push(options.namespace);
    options.defaultNS = options.namespace;
  } else if (options.namespaceFromPath) {
    var ns = getPathname();
    options.ns.push(ns);
    options.defaultNS = ns;
  }

  if (!options.ns.length) options.ns = ['translation'];

  if (options.ignoreTags) {
    options.ignoreTags = options.ignoreTags.map(function (s) {
      return s.toUpperCase();
    });
  }

  if (options.ignoreCleanIndentFor) {
    options.ignoreCleanIndentFor = options.ignoreCleanIndentFor.map(function (s) {
      return s.toUpperCase();
    });
  }

  if (options.inlineTags) {
    options.inlineTags = options.inlineTags.map(function (s) {
      return s.toUpperCase();
    });
  }

  if (options.ignoreInlineOn) {
    options.ignoreInlineOn = options.ignoreInlineOn.map(function (s) {
      return s.toUpperCase();
    });
  }

  if (options.mergeTags) {
    options.mergeTags = options.mergeTags.map(function (s) {
      return s.toUpperCase();
    });
  }

  options.translateAttributes = options.translateAttributes.reduce(function (mem, attr) {
    var res = {
      attr: attr
    };

    if (attr.indexOf('#') > -1) {
      var _attr$split = attr.split('#'),
          _attr$split2 = _slicedToArray(_attr$split, 2),
          a = _attr$split2[0],
          c = _attr$split2[1];

      res.attr = a;

      if (c.indexOf('.') > -1) {
        var _c$split = c.split('.'),
            _c$split2 = _slicedToArray(_c$split, 2),
            e = _c$split2[0],
            b = _c$split2[1];

        res.ele = e.toUpperCase();
        res.cond = b.toLowerCase().split('=');
      } else if (c.indexOf('=') > -1) {
        res.cond = c.toLowerCase().split('=');
      } else {
        res.ele = c.toUpperCase();
      }
    }

    mem.push(res);
    return mem;
  }, []);
  return options;
};