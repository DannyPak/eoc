"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = localize;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _vdomToHtml = _interopRequireDefault(require("vdom-to-html"));

var _vdomParser = _interopRequireDefault(require("vdom-parser"));

var _vnode = _interopRequireDefault(require("virtual-dom/vnode/vnode"));

var _i18next = _interopRequireDefault(require("i18next"));

var _utils = require("./utils");

var _Instrument = _interopRequireDefault(require("./Instrument"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isUnTranslated(node) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    retranslate: false
  };
  if (opts && opts.retranslate) return true;
  return !node.properties || !node.properties.attributes || node.properties.attributes.localized !== '';
}

function isNotExcluded(node) {
  var ret = !node.properties || !node.properties.attributes || node.properties.attributes.translated !== '';

  if (ret && node.tagName && _i18next["default"].options.ignoreTags.indexOf(node.tagName) > -1) {
    ret = false;
  }

  if (ret && _i18next["default"].options.ignoreClasses && node.properties && node.properties.className) {
    var p = node.properties.className.split(' ');
    p.forEach(function (cls) {
      if (!ret) return;
      if (_i18next["default"].options.ignoreClasses.indexOf(cls) > -1) ret = false;
    });
  }

  if (ret && _i18next["default"].options.ignoreIds) {
    if (_i18next["default"].options.ignoreIds.indexOf(node.properties && node.properties.id) > -1) {
      ret = false;
    }
  }

  return ret;
}

function translate(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var overrideKey = arguments.length > 2 ? arguments[2] : undefined;
  var hasContent = str.trim();
  var key = overrideKey || str.trim();
  if (!options.defaultValue) options.defaultValue = str;

  if (hasContent && !_i18next["default"].options.ignoreWithoutKey || hasContent && _i18next["default"].options.ignoreWithoutKey && overrideKey) {
    return _i18next["default"].t(key, options);
  }

  return str;
}

var replaceInside = ['src', 'href'];
var REGEXP = new RegExp('%7B%7B(.+?)%7D%7D', 'g'); // urlEncoded {{}}

function translateProps(node, props) {
  var tOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var overrideKey = arguments.length > 3 ? arguments[3] : undefined;
  var realNodeIsUnTranslated = arguments.length > 4 ? arguments[4] : undefined;
  var opts = arguments.length > 5 ? arguments[5] : undefined;
  if (!props) return props;

  _i18next["default"].options.translateAttributes.forEach(function (item) {
    if (item.ele && node.tagName !== item.ele) return;

    if (item.cond && item.cond.length === 2) {
      var condValue = (0, _utils.getPath)(props, item.cond[0]) || (0, _utils.getPath)(props.attributes, item.cond[0]);
      if (!condValue || condValue !== item.cond[1]) return;
    }

    var wasOnAttr = false;
    var value = (0, _utils.getPath)(props, item.attr);

    if (!value) {
      value = (0, _utils.getPath)(props.attributes, item.attr);
      if (value) wasOnAttr = true;
    }

    if (opts.retranslate) {
      var usedValue = node.properties && node.properties && node.properties.attributes["".concat(item.attr, "-i18next-orgval")];
      if (!usedValue) usedValue = value;
      value = usedValue;
    }

    if (value) {
      if (realNodeIsUnTranslated) {
        node.properties.attributes["".concat(item.attr, "-i18next-orgval")] = value;
      }

      (0, _utils.setPath)(wasOnAttr ? props.attributes : props, item.attr, translate(value, _objectSpread({}, tOptions), overrideKey ? "".concat(overrideKey, ".").concat(item.attr) : ''));
    }
  });

  replaceInside.forEach(function (attr) {
    var value = (0, _utils.getPath)(props, attr);

    if (value) {
      value = value.replace(/\{\{/g, '%7B%7B').replace(/\}\}/g, '%7D%7D');
    } // fix for safari


    if (value && value.indexOf('%7B') > -1) {
      var arr = [];
      value.split(REGEXP).reduce(function (mem, match, index) {
        if (match.length === 0) return mem;

        if (!index || index % 2 === 0) {
          mem.push(match);
        } else {
          mem.push(translate(match, _objectSpread({}, tOptions), overrideKey ? "".concat(overrideKey, ".").concat(attr) : ''));
        }

        return mem;
      }, arr);
      if (arr.length) (0, _utils.setPath)(props, attr, arr.join(''));
    }
  });
  return props;
}

function getTOptions(opts, node) {
  var optsOnNode = (0, _utils.getAttribute)(node, 'i18next-options');

  if (optsOnNode) {
    try {
      optsOnNode = JSON.parse(optsOnNode);
    } catch (e) {
      console.warn('failed parsing options on node', node);
    }
  }

  if (optsOnNode && optsOnNode.inlineTags) {
    optsOnNode.inlineTags = optsOnNode.inlineTags.map(function (s) {
      return s.toUpperCase();
    });
  }

  return _objectSpread(_objectSpread({}, opts || {}), optsOnNode || {});
}

function removeIndent(str, substitution) {
  if (!_i18next["default"].options.cleanIndent) return str;
  var ret = str.replace(/\n +/g, substitution);
  return ret;
}

function canInline(node, tOptions) {
  if (!node.children || !node.children.length || _i18next["default"].options.ignoreInlineOn.indexOf(node.tagName) > -1) {
    return false;
  }

  if (_i18next["default"].options.mergeTags.indexOf(node.tagName) > -1) return true;
  var baseTags = tOptions.inlineTags || _i18next["default"].options.inlineTags;
  var inlineTags = tOptions.additionalInlineTags ? baseTags.concat(tOptions.additionalInlineTags) : baseTags;
  var inlineable = true;
  var hadNonTextNode = false;
  node.children.forEach(function (child) {
    if (!child.text && child.tagName && inlineTags.indexOf(child.tagName.toUpperCase()) < 0) {
      inlineable = false;
    }

    if (child.tagName) hadNonTextNode = true;
  });
  return inlineable && hadNonTextNode;
}

function walk(node, tOptions, parent, parentOverrideKey) {
  var currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var opts = arguments.length > 5 ? arguments[5] : undefined;
  var nodeIsNotExcluded = isNotExcluded(node);
  var nodeIsUnTranslated = isUnTranslated(node, opts);
  var realNodeIsUnTranslated = isUnTranslated(node); // ignoring forced threatment

  tOptions = getTOptions(tOptions, node);
  var parentKey = currentDepth === 0 ? parentOverrideKey : '';

  if (currentDepth > 0 && parentOverrideKey && !_i18next["default"].options.ignoreWithoutKey) {
    parentKey = "".concat(parentOverrideKey, ".").concat(currentDepth);
  }

  var overrideKey = (0, _utils.getAttribute)(node, _i18next["default"].options.keyAttr) || parentKey; // normally we use content as key, but optionally we allow to override it
  // translate node as one block

  var mergeFlag = (0, _utils.getAttribute)(node, 'merge');

  if (mergeFlag !== 'false' && (mergeFlag === '' || canInline(node, tOptions))) {
    if (nodeIsNotExcluded && nodeIsUnTranslated) {
      // wrap children into dummy node and remove that outer from translation
      var dummyNode = new _vnode["default"]('I18NEXTIFYDUMMY', null, node.children);
      var key = removeIndent((0, _vdomToHtml["default"])(dummyNode), '').replace('<i18nextifydummy>', '').replace('</i18nextifydummy>', ''); // grab orginial text if we enforce a retranslate

      if (opts.retranslate) {
        var usedKey = node.properties && node.properties.attributes && node.properties.attributes['i18next-orgval'];

        if (!usedKey) {
          usedKey = parent && parent.properties && parent.properties.attributes && parent.properties.attributes["i18next-orgval-".concat(currentDepth)];
        }

        if (!usedKey) usedKey = key;
        key = usedKey;
      } // translate that's children and surround it again with a dummy node to parse to vdom


      var translation = "<i18nextifydummy>".concat(translate(key, tOptions, overrideKey), "</i18nextifydummy>");
      var newNode = (0, _vdomParser["default"])((translation || '').trim()); // replace children on passed in node

      node.children = newNode.children; // persist original key for future retranslate

      if (realNodeIsUnTranslated && node.properties && node.properties.attributes) {
        node.properties.attributes['i18next-orgval'] = key;
      } else if (realNodeIsUnTranslated && parent && parent.properties && parent.properties.attributes) {
        parent.properties.attributes["i18next-orgval-".concat(currentDepth)] = key;
      }

      if (node.properties && node.properties.attributes) {
        node.properties.attributes.localized = '';
      }
    }

    return node;
  }

  if (node.children) {
    node.children.forEach(function (child, i) {
      if (nodeIsNotExcluded && nodeIsUnTranslated && child.text || !child.text && isNotExcluded(child)) {
        walk(child, tOptions, node, overrideKey, node.children.length > 1 ? i + 1 : i, // if only a inner text node - keep it index 0, else add a index number + 1
        opts);
      }
    });
  } // ignore comments


  if (node.text && !node.properties && node.type === 'Widget') return node;

  if (nodeIsNotExcluded && nodeIsUnTranslated) {
    if (node.text) {
      var match;
      var txt = node.text;
      var originalText = node.text; // grab orginial text if we enforce a retranslate

      if (opts.retranslate) {
        var usedText = node.properties && node.properties.attributes && node.properties.attributes['i18next-orgval'];

        if (!usedText) {
          usedText = parent && parent.properties && parent.properties.attributes && parent.properties.attributes["i18next-orgval-".concat(currentDepth)];
        }

        if (!usedText) usedText = node.text;
        txt = usedText;
        originalText = usedText;
      } // exclude whitespace replacement eg on PRE, CODE


      var ignore = _i18next["default"].options.ignoreCleanIndentFor.indexOf(parent.tagName) > -1;

      if (!ignore) {
        txt = removeIndent(txt, '\n');

        if (_i18next["default"].options.cleanWhitespace) {
          var regex = /^\s*(.*[^\s])\s*$/g;
          match = regex.exec(txt);
        }
      }

      if (!ignore && match && match.length > 1 && _i18next["default"].options.cleanWhitespace) {
        var _translation = translate(match[1], tOptions, overrideKey || '');

        node.text = txt.replace(match[1], _translation);
      } else {
        node.text = translate(txt, tOptions, overrideKey || '');
      } // persist original text (key) for future retranslate


      if (realNodeIsUnTranslated && node.properties && node.properties.attributes) {
        if (originalText) {
          node.properties.attributes['i18next-orgval'] = originalText;
        }
      } else if (realNodeIsUnTranslated && parent && parent.properties && parent.properties.attributes) {
        if (originalText) {
          parent.properties.attributes["i18next-orgval-".concat(currentDepth)] = originalText;
        }
      }
    } // translate propertied


    if (node.properties) {
      node.properties = translateProps(node, node.properties, tOptions, overrideKey, realNodeIsUnTranslated, opts);
    } // set translated


    if (node.properties && node.properties.attributes) {
      node.properties.attributes.localized = '';
    }
  }

  return node;
}

function localize(node, retranslate) {
  var recurseTime = new _Instrument["default"]();
  recurseTime.start();
  var localized = walk(node, null, null, null, null, {
    retranslate: retranslate
  });

  _i18next["default"].services.logger.log("localization took: ".concat(recurseTime.end(), "ms"));

  return localized;
}