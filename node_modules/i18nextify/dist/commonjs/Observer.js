"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _EventEmitter2 = _interopRequireDefault(require("./EventEmitter"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var Observer = /*#__PURE__*/function (_EventEmitter) {
  (0, _inherits2["default"])(Observer, _EventEmitter);

  var _super = _createSuper(Observer);

  function Observer(ele) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2["default"])(this, Observer);
    _this = _super.call(this);
    _this.ele = ele;
    _this.options = options;
    _this.observer = _this.create();
    _this.internalChange = true;
    return _this;
  }

  (0, _createClass2["default"])(Observer, [{
    key: "create",
    value: function create() {
      var _this2 = this;

      var lastToggleTimeout;

      var toggleInternal = function toggleInternal() {
        if (lastToggleTimeout) window.clearTimeout(lastToggleTimeout);
        lastToggleTimeout = setTimeout(function () {
          if (_this2.internalChange) _this2.internalChange = false;
        }, 200);
      };

      var observer = new MutationObserver(function (mutations) {
        // For the sake of...observation...let's output the mutation to console to see how this all works
        // mutations.forEach(function(mutation) {
        // 	console.log(mutation.type);
        // });
        if (_this2.internalChange) toggleInternal();
        if (!_this2.internalChange) _this2.emit('changed', mutations);
      }); // Notify me of everything!

      var observerConfig = {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      }; // Node, config
      // In this case we'll listen to all changes to body and child nodes

      observer.observe(this.ele, observerConfig);
      return observer;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.internalChange = true;
    }
  }]);
  return Observer;
}(_EventEmitter2["default"]);

exports["default"] = Observer;